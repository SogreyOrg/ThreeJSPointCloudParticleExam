/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet ThreeIns;\r\n\r\nThreeIns = new ThreeJsClass();\r\nwindow.ThreeIns = ThreeIns;\r\n\r\n\r\n//test \r\n\r\n\r\n\r\n\tfunction ThreeJsClass() {\r\n        if (!Detector.webgl) {\r\n            Detector.addGetWebGLMessage()\r\n        };\r\n\r\n        setTimeout(() => {\r\n            let maxTime = 0;\r\n            bisN = true;\r\n            particles_wave.forEach(function (e,i,arr)\r\n            {\r\n                let time_exec = Math.random() * 500 + 500 ;\r\n                let time_delay = Math.random() * 300 ;\r\n                maxTime =( maxTime > time_exec + time_delay ?maxTime :time_exec + time_delay );\r\n                let tweenIns = new TWEEN.Tween(e.position).to(\r\n                    {\r\n                        x:wave_coord[i].x, \r\n                        y:wave_coord[i].y,\r\n                        z:wave_coord[i].z\r\n                    },time_exec).easing(TWEEN.Easing.Quadratic.InOut).delay(time_delay);\r\n                tweenIns.start();\r\n            });\r\n\r\n            setTimeout(() => {\r\n                bWavesing = true;\r\n            }, maxTime - 200);\r\n        }, 1000);\r\n\r\n        let container, stats;\r\n        let camera, scene, renderer, geometry, materials = [], parameters, i, h, color, size;\r\n        let mouseX = 0, mouseY = 0;\r\n        let windowHalfX = window.innerWidth / 2;\r\n        let windowHalfY = window.innerHeight / 2;\r\n\r\n        let geom;\r\n        let mat;\r\n\r\n        let bflag = true;\r\n        let bWavesing = false;\r\n        let bisN = false;\r\n\r\n\r\n        /**\r\n         * 辉光\r\n         * */\r\n\r\n        var composer, mixer;\r\n        var params = {\r\n            exposure: 2,\r\n            bloomStrength: 2,\r\n            bloomThreshold: 0,\r\n            bloomRadius: 0\r\n        };\r\n\r\n        /**\r\n         * 辉光\r\n         */\r\n         \r\n        /**\r\n         * 波浪 start\r\n         */\r\n\r\n        const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;\r\n        let particles_wave = new Array();\r\n        let particle_wave;\r\n        let geometry_wave = new THREE.Geometry();\r\n        let count_wave = 1;\r\n        let wave_coord = new Array();\r\n        \r\n        /**\r\n         * 波浪 end\r\n         */\r\n\r\n        /**\r\n         * img 数据 start\r\n         */\r\n        let canvas = document.createElement('canvas');\r\n        let content = canvas.getContext('2d');\r\n        let img = new Image();\r\n        let imgData ;\r\n        img.src = \"static/img/5.png\";\r\n        canvas.style.position = 'absolute';\r\n\r\n        if (window.innerWidth > 720)\r\n        {\r\n            canvas.width = 250;\r\n            canvas.height = 250;\r\n        }\r\n        else \r\n        {\r\n            canvas.width = 200;\r\n            canvas.height = 200;\r\n        }\r\n\r\n        \r\n        canvas.style.display = 'none';\r\n\r\n        let imgCoord = [];\r\n        let imgVecColor = [];\r\n        /**\r\n         * img 数据 end\r\n         */\r\n\r\n        this.init = function()\r\n        {\r\n            let _this = this;\r\n            img.onload = function () {\r\n                content.drawImage(img, 0, 0 ,canvas.width, canvas.height);\r\n                imgData = content.getImageData(0,0,canvas.width, canvas.height);\r\n                _this.initThreeJS();\r\n            };\r\n        }\r\n\r\n        this.initPost = function()\r\n        {\r\n            setTimeout(function ()\r\n            {\r\n                var renderScene = new THREE.RenderPass( scene, camera );\r\n                let bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );\r\n                bloomPass.threshold = params.bloomThreshold;\r\n                bloomPass.strength = params.bloomStrength;\r\n                bloomPass.radius = params.bloomRadius;\r\n    \r\n                composer = new THREE.EffectComposer( renderer );\r\n                composer.setSize( window.innerWidth, window.innerHeight );\r\n                composer.addPass( renderScene );\r\n                composer.addPass( bloomPass );\r\n            },1500);\r\n\r\n        }\r\n\r\n\r\n        this.initThreeJS = function () {\r\n\r\n            container = document.createElement('div');\r\n            container.id = 'threejsDiv';\r\n            document.body.appendChild(container);\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);\r\n            camera.position.z = 1000;\r\n            scene = new THREE.Scene();\r\n            scene.fog = new THREE.FogExp2(0x000000, 0.0005);\r\n\r\n\r\n            console.log(renderer);\r\n            renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\r\n            renderer.setPixelRatio((window.devicePixelRatio) ? window.devicePixelRatio : 1);\r\n            renderer.autoClear = false;\r\n            renderer.setClearColor(0x000000, 0);\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n            container.appendChild(renderer.domElement);\r\n            stats = new Stats();\r\n            //container.appendChild(stats.dom);\r\n            document.addEventListener('mousemove', onDocumentMouseMove, false);\r\n            document.addEventListener('touchstart', onDocumentTouchStart, false);\r\n            document.addEventListener('touchmove', onDocumentTouchMove, false);\r\n            window.addEventListener('resize', onWindowResize, false);\r\n\r\n            this.initPost();\r\n\r\n            geometry = new THREE.Geometry();\r\n            geom = new THREE.Geometry();\r\n\r\n            //let t2d_point = new THREE.TextureLoader().load( 'point.png')\r\n\r\n            //this.GenrateGeom(geom);\r\n            GenrateWaves();\r\n\r\n            //scene.add(new THREE.Points( new THREE.TextGeometry('Threejs Hello Wolrd'), mat));\r\n\r\n\r\n            GenrateAround();\r\n\r\n            var lights = [];\r\n\r\n            lights[0] = new THREE.DirectionalLight(0xffffff, 1);\r\n            lights[0].position.set(1, 0, 0);\r\n            lights[1] = new THREE.DirectionalLight(0x11E8BB, 1);\r\n            lights[1].position.set(0.75, 1, 0.5);\r\n            lights[2] = new THREE.DirectionalLight(0x8200C9, 1);\r\n            lights[2].position.set(-0.75, -1, 0.5);\r\n            scene.add(lights[0]);\r\n            scene.add(lights[1]);\r\n            scene.add(lights[2]);\r\n\r\n            animate();\r\n        }\r\n\r\n        function IsTransparent(x, y) {\r\n            let total = canvas.width * canvas.height * 4;\r\n            let index = total - (x * canvas.height * 4) + (y * 4);\r\n            return (parseInt(imgData.data[index + 3]) != 0);\r\n        }\r\n\r\n        function GetVecColor(x, y) {\r\n            let total = canvas.width * canvas.height * 4;\r\n            let index = total - (x * canvas.height * 4) + (y * 4);\r\n            let color = new THREE.Color(imgData.data[index] / 255, imgData.data[index + 1] / 255, imgData.data[index + 2] / 255);\r\n            return color;\r\n        }\r\n\r\n\r\n        function GenrateAround()\r\n        {\r\n            \r\n            for (i = 0; i < 50; i++) {\r\n                var vertex = new THREE.Vector3();\r\n                vertex.x = Math.random() * 2000 - 1000;\r\n                vertex.y = Math.random() * 2000 - 1000;\r\n                vertex.z = Math.random() * 2010 - 1000;\r\n                geometry.vertices.push(vertex);\r\n                geometry.colors.push(1.0, 1.0, 1.0);\r\n            }\r\n\r\n            parameters = [\r\n                [[1, 1, 0.5],    5],\r\n                [[0.95, 1, 0.5], 8],\r\n                [[0.90, 1, 0.5], 8],\r\n                [[0.85, 1, 0.5], 8],\r\n                [[0.80, 1, 0.5], 8]\r\n            ];\r\n            let loader = new THREE.TextureLoader();\r\n            let t2d = loader.load('static/img/point1.png');\r\n            for (i = 0; i < 5; i++) {\r\n                //color = // [Math.random() * 255, Math.random() * 255, Math.random() * 255, Math.random() * 255];\r\n                size = Math.random() * 10 + 1;\r\n\r\n                materials[i] = new THREE.PointsMaterial(\r\n                    {\r\n                        transparent:true, //使材质透明\r\n                        blending:THREE.AdditiveBlending, //\r\n                        depthTest:false, //深度测试关闭，不消去场景的不可见\r\n                        size: size,\r\n                        map:t2d\r\n                    });\r\n                let particles = new THREE.Points(geometry, materials[i]);\r\n\r\n                particles.rotation.x = Math.random() * 0;\r\n                particles.rotation.y = Math.random() * 6;\r\n                particles.rotation.z = Math.random() * 6;\r\n\r\n                particles.name = 'around';\r\n                scene.add(particles);\r\n            }\r\n        }\r\n\r\n        function GenrateWaves() {\r\n\r\n            let partile_geometry = new THREE.SphereGeometry( 1, 32, 16 );\r\n            let temp_color = new THREE.Color().setRGB(152,215,233);\r\n            let temp_mat = new THREE.MeshLambertMaterial( { color:temp_color } );\r\n\r\n            let loader = new THREE.TextureLoader();\r\n            let t2d = loader.load('static/img/point1.png');\r\n\r\n            let i_wave = 0;\r\n            for ( let ix = 0; ix < AMOUNTX; ix++ ) {\r\n                for ( let iy = 0; iy < AMOUNTY; iy++ ) {\r\n                    let temp_sprite_color = new THREE.Color().setRGB(125,253,255);\r\n                    let material_wave = new THREE.SpriteMaterial({\r\n                        map: t2d,\r\n                        useScreenCoordinates: false, \r\n                        color: temp_sprite_color, \r\n                        transparent: false, \r\n                        blending: THREE.AdditiveBlending\r\n                    });\r\n\r\n                    wave_coord.push(new THREE.Vector3 ( ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2), -500,iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2) ) );\r\n                    let follow_particle = new THREE.Sprite(material_wave);\r\n                    let particle_mesh = new THREE.Mesh( partile_geometry, temp_mat );\r\n                    particle_wave = particles_wave[i_wave++] = particle_mesh;\r\n                    \r\n                    particle_wave.position.x = Math.random() * 9000 - 4500;\r\n                    particle_wave.position.z = Math.random() * 9000 - 4500;\r\n                    particle_wave.position.y = Math.random() * 9000 - 4500;\r\n                    \r\n\r\n                    particle_wave.scale.x = particle_wave.scale.y = Math.random() * 5 + 1;\r\n                    follow_particle.scale.set(2.4, 2.4, 2.4);\r\n                    particle_wave.add(follow_particle);\r\n                    \r\n                    //let particle_mesh = new THREE.Mesh( geometry, material );\r\n                    \r\n\r\n                    scene.add(particle_wave);\r\n\r\n                    if (i_wave > 0) \r\n                    {\r\n                        geometry_wave.vertices.push(particle_wave.position);\r\n                    }\r\n                }\r\n            }\r\n            console.log(particle_wave);\r\n        }\r\n\r\n        this.GenrateGeom = function (_geom) {\r\n            console.log(canvas.height);\r\n            let temp_subHeight =  (canvas.height < 250 ? canvas.height * 1.5 : canvas.height);\r\n            for (var x = 0; x < canvas.width; x++) {\r\n                for (var y = 0; y < canvas.height; y++) {\r\n                    let vec = new THREE.Vector3(y - canvas.width / 2,\r\n                                                x - canvas.height / 2,\r\n                                                1000 - temp_subHeight);\r\n\r\n                    let vec_random = new THREE.Vector3( Math.random() * document.body.clientWidth * 4 - document.body.clientWidth * 2,\r\n                                                        Math.random() * document.body.clientHeight * 4 - document.body.clientHeight * 2,\r\n                                                        Math.random() * 4000 - 2000);\r\n\r\n                    if (IsTransparent(x, y)) {\r\n                        let color = GetVecColor(x, y);\r\n\r\n                        _geom.vertices.push(vec_random);\r\n                        _geom.colors.push(color);\r\n                        imgCoord.push(vec);\r\n                        imgVecColor.push(color);\r\n                    } \r\n                }\r\n            }\r\n            _geom.center();\r\n\r\n            mat = new THREE.PointsMaterial({size: 2, vertexColors: true});\r\n            let cloud = new THREE.Points(geom, mat);\r\n\r\n            cloud.name = 'ImageParticle';\r\n            cloud.rotation.y = Math.PI * 1.8;\r\n            scene.add(cloud);\r\n        }\r\n\r\n        this.tweenAnim = function tweenObj(index) {\r\n            if (geom.vertices.length <= 0)\r\n            {\r\n                this.GenrateGeom(geom);\r\n            }\r\n            else \r\n            {\r\n\r\n                geom.vertices.forEach(function (e, i, arr) {\r\n                    let tweenIns = new TWEEN.Tween(e).to(\r\n                        {\r\n                            x: imgCoord[i].x,\r\n                            y: imgCoord[i].y,\r\n                            z: imgCoord[i].z\r\n                        }, Math.random() * 750 ).easing(TWEEN.Easing.Quadratic.InOut)\r\n                        .delay(Math.random() * 250 );\r\n                    tweenIns.start();\r\n    \r\n                });\r\n    \r\n            }\r\n\r\n        };\r\n\r\n        this.tweenAnim1 = function tweenObj(index) {\r\n            geom.vertices.forEach(function (e, i, arr) {\r\n\r\n                if (Math.random() * 100 > 0) {\r\n                    let tweenIns = new TWEEN.Tween(e).to(\r\n                        {\r\n                            x: imgCoord[i].x * 10,\r\n                            y: imgCoord[i].y * 10,\r\n                            z: imgCoord[i].z * 2 > 1000 ? e.z * 2 : 1001//e.z\r\n                        }, Math.random() * 750 ).easing(TWEEN.Easing.Quadratic.InOut)\r\n                        .delay(Math.random() * 250);\r\n                    tweenIns.start();\r\n                } else {\r\n\r\n\r\n                }\r\n\r\n            })\r\n\r\n        };\r\n\r\n\r\n        this.tweenAnim2 = function tweenObj(index) {\r\n            for (let sceneItem of scene.children) {\r\n                sceneItem.name = \"ImageParticle\";\r\n            }\r\n            setTimeout(() => {\r\n                for (let sceneItem of scene.children) {\r\n                    sceneItem.material.size = 2.5;\r\n                }\r\n            }, 1500);\r\n\r\n            geometry.vertices.forEach(function (e, i, arr) {\r\n                let tweenIns = new TWEEN.Tween(e).to(\r\n                    {\r\n                        x: imgCoord[i].x,\r\n                        y: imgCoord[i].y,\r\n                        z: imgCoord[i].z//e.z\r\n                    }, Math.random() * 500).easing(TWEEN.Easing.Quadratic.In)\r\n                    .delay(Math.random() * 500)\r\n                    .onUpdate(function (i) {\r\n                            geometry.colors[i] = imgVecColor[i];\r\n                        }\r\n                    );\r\n                tweenIns.start();\r\n            });\r\n        };\r\n\r\n        this.tweenAnim3 = function () {\r\n            let bflag = true;\r\n            let bWavesing = false;\r\n        };\r\n\r\n        function onWindowResize() {\r\n            windowHalfX = window.innerWidth / 2;\r\n            windowHalfY = window.innerHeight / 2;\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function onDocumentMouseMove(event) {\r\n            mouseX = event.clientX - windowHalfX;\r\n            mouseY = event.clientY - windowHalfY;\r\n        }\r\n\r\n        function onDocumentTouchStart(event) {\r\n            if (event.touches.length === 1) {\r\n                event.preventDefault();\r\n                mouseX = event.touches[0].pageX - windowHalfX;\r\n                mouseY = event.touches[0].pageY - windowHalfY;\r\n            }\r\n        }\r\n\r\n        function onDocumentTouchMove(event) {\r\n            if (event.touches.length === 1) {\r\n                event.preventDefault();\r\n                mouseX = event.touches[0].pageX - windowHalfX;\r\n                mouseY = event.touches[0].pageY - windowHalfY;\r\n            }\r\n        }\r\n\r\n        //\r\n        function animate(time) {\r\n            requestAnimationFrame(animate);\r\n            TWEEN.update(time);\r\n            render();\r\n            stats.update();\r\n        }\r\n\r\n\r\n        function render() {\r\n            var time = Date.now() * 0.00005;\r\n\r\n            if (((mouseX - camera.position.x) > 0 && camera.position.x <  50) ||\r\n                ((mouseX - camera.position.x) < 0 && camera.position.x > -50)) {\r\n                camera.position.x += (mouseX - camera.position.x) * 0.002;\r\n            }\r\n            if (((mouseY - camera.position.y) > 0 && camera.position.y < 50) ||\r\n                ((mouseY - camera.position.y) < 0 && camera.position.y > -50)) {\r\n                camera.position.y += (mouseY - camera.position.y) * 0.005;\r\n            }\r\n            \r\n            camera.lookAt(scene.position);\r\n\r\n            geom.verticesNeedUpdate = true;\r\n            geom.colorsNeedUpdate = true;\r\n            geometry.verticesNeedUpdate = true;\r\n            geometry.colorsNeedUpdate = true;\r\n\r\n\r\n            render_around(time);\r\n            render_wave();\r\n            //for ( i = 0; i < materials.length; i ++ ) {\r\n            //\tcolor = parameters[i][0];\r\n            //\th = ( 360 * ( color[0] + time ) % 360 ) / 360;\r\n            //\tmaterials[i].color.setHSL( h, color[1], color[2] );\r\n            //}\r\n\r\n            renderer.render(scene, camera);\r\n            count_wave += 0.1;\r\n        }\r\n\r\n        function render_around(time)\r\n        {\r\n            let i_around = 0;\r\n            for (let i = 0; i < scene.children.length; i++) {\r\n                var object = scene.children[i];\r\n                if (object.name === 'around' && object instanceof THREE.Points) {\r\n                    object.rotation.y = time * (i_around < 4 ? i_around + 1 : -(i_around + 1)) * 2.5;\r\n                    i_around++;\r\n                }\r\n                else if (object.name === 'ImageParticle') {\r\n                    if (object.rotation.y < 6.28318) \r\n                    {\r\n                        object.rotation.y += Math.PI / 180 * 2;\r\n                    } \r\n                    else if (bflag) \r\n                    {\r\n                        bflag = false;\r\n                        console.log(object.rotation.y);\r\n                        object.rotation.y = 6.283185307179586;\r\n                        ThreeIns.tweenAnim();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function render_wave() {\r\n            let i_wave = 0;\r\n\r\n            if ((particles_wave.length > AMOUNTX * AMOUNTY)) {\r\n                return;\r\n            }\r\n\r\n            if ( bWavesing  )\r\n            {\r\n                /**waves */\r\n                for (let ix = 0; ix < AMOUNTX; ix++) {\r\n                    for (let iy = 0; iy < AMOUNTY; iy++) {\r\n                        let tx = ix;\r\n                        let ty = iy;\r\n\r\n                        particle_wave = particles_wave[i_wave++];\r\n                        \r\n\r\n                        //particle_wave.position.y  = //particle_wave.position.y + \r\n                        //                            ( Math.sin( ( ix + count_wave ) * 0.3 ) * 50 ) + ( Math.sin( ( iy + count_wave ) * 0.4 ) * 50 ) - 500;\r\n                        particle_wave.position.y = particle_wave.position.y + Math.sin((tx + count_wave) * 0.3) * 2 + (Math.sin((ty + count_wave) * 0.5)) * 2;\r\n                        particle_wave.scale.x = particle_wave.scale.y = (Math.sin((tx + count_wave) * 0.3) + 1) * 2.5 + (Math.sin((ty + count_wave) * 0.5) + 1) * 2.5;\r\n                    }\r\n                }\r\n            }\r\n            else \r\n            {   \r\n                if (!bisN)\r\n                {\r\n                    for (let ix = 0; ix < AMOUNTX; ix++) {\r\n                        for (let iy = 0; iy < AMOUNTY; iy++) {\r\n                            \r\n                            particle_wave = particles_wave[i_wave++];\r\n                            let temp_rad = Math.random() * 0.05 + 0.01 ;\r\n                            particle_wave.position.x = particle_wave.position.z * Math.sin(temp_rad) + particle_wave.position.x * Math.cos(temp_rad);\r\n                            particle_wave.position.z = particle_wave.position.z * Math.cos(temp_rad) - particle_wave.position.x * Math.sin(temp_rad);\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n            //tex+= 0.1;\r\n        }\r\n\r\n        this.init();\r\n    }\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ThreeIns);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJZSx1RUFBUSIsImZpbGUiOiIuL3NyYy9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IFRocmVlSW5zO1xyXG5cclxuVGhyZWVJbnMgPSBuZXcgVGhyZWVKc0NsYXNzKCk7XHJcbndpbmRvdy5UaHJlZUlucyA9IFRocmVlSW5zO1xyXG5cclxuXHJcbi8vdGVzdCBcclxuXHJcblxyXG5cclxuXHRmdW5jdGlvbiBUaHJlZUpzQ2xhc3MoKSB7XHJcbiAgICAgICAgaWYgKCFEZXRlY3Rvci53ZWJnbCkge1xyXG4gICAgICAgICAgICBEZXRlY3Rvci5hZGRHZXRXZWJHTE1lc3NhZ2UoKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbWF4VGltZSA9IDA7XHJcbiAgICAgICAgICAgIGJpc04gPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZXNfd2F2ZS5mb3JFYWNoKGZ1bmN0aW9uIChlLGksYXJyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZV9leGVjID0gTWF0aC5yYW5kb20oKSAqIDUwMCArIDUwMCA7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZV9kZWxheSA9IE1hdGgucmFuZG9tKCkgKiAzMDAgO1xyXG4gICAgICAgICAgICAgICAgbWF4VGltZSA9KCBtYXhUaW1lID4gdGltZV9leGVjICsgdGltZV9kZWxheSA/bWF4VGltZSA6dGltZV9leGVjICsgdGltZV9kZWxheSApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHR3ZWVuSW5zID0gbmV3IFRXRUVOLlR3ZWVuKGUucG9zaXRpb24pLnRvKFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDp3YXZlX2Nvb3JkW2ldLngsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OndhdmVfY29vcmRbaV0ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejp3YXZlX2Nvb3JkW2ldLnpcclxuICAgICAgICAgICAgICAgICAgICB9LHRpbWVfZXhlYykuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuSW5PdXQpLmRlbGF5KHRpbWVfZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgdHdlZW5JbnMuc3RhcnQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGJXYXZlc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sIG1heFRpbWUgLSAyMDApO1xyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICBsZXQgY29udGFpbmVyLCBzdGF0cztcclxuICAgICAgICBsZXQgY2FtZXJhLCBzY2VuZSwgcmVuZGVyZXIsIGdlb21ldHJ5LCBtYXRlcmlhbHMgPSBbXSwgcGFyYW1ldGVycywgaSwgaCwgY29sb3IsIHNpemU7XHJcbiAgICAgICAgbGV0IG1vdXNlWCA9IDAsIG1vdXNlWSA9IDA7XHJcbiAgICAgICAgbGV0IHdpbmRvd0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xyXG4gICAgICAgIGxldCB3aW5kb3dIYWxmWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIGxldCBnZW9tO1xyXG4gICAgICAgIGxldCBtYXQ7XHJcblxyXG4gICAgICAgIGxldCBiZmxhZyA9IHRydWU7XHJcbiAgICAgICAgbGV0IGJXYXZlc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBiaXNOID0gZmFsc2U7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDovonlhYlcclxuICAgICAgICAgKiAqL1xyXG5cclxuICAgICAgICB2YXIgY29tcG9zZXIsIG1peGVyO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGV4cG9zdXJlOiAyLFxyXG4gICAgICAgICAgICBibG9vbVN0cmVuZ3RoOiAyLFxyXG4gICAgICAgICAgICBibG9vbVRocmVzaG9sZDogMCxcclxuICAgICAgICAgICAgYmxvb21SYWRpdXM6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDovonlhYlcclxuICAgICAgICAgKi9cclxuICAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rOi5rWqIHN0YXJ0XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGNvbnN0IFNFUEFSQVRJT04gPSAxMDAsIEFNT1VOVFggPSA1MCwgQU1PVU5UWSA9IDUwO1xyXG4gICAgICAgIGxldCBwYXJ0aWNsZXNfd2F2ZSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIGxldCBwYXJ0aWNsZV93YXZlO1xyXG4gICAgICAgIGxldCBnZW9tZXRyeV93YXZlID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgbGV0IGNvdW50X3dhdmUgPSAxO1xyXG4gICAgICAgIGxldCB3YXZlX2Nvb3JkID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rOi5rWqIGVuZFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpbWcg5pWw5o2uIHN0YXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGxldCBpbWdEYXRhIDtcclxuICAgICAgICBpbWcuc3JjID0gXCJzdGF0aWMvaW1nLzUucG5nXCI7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gNzIwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMjUwO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjUwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMjAwO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGxldCBpbWdDb29yZCA9IFtdO1xyXG4gICAgICAgIGxldCBpbWdWZWNDb2xvciA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGltZyDmlbDmja4gZW5kXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50LmRyYXdJbWFnZShpbWcsIDAsIDAgLGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpbWdEYXRhID0gY29udGVudC5nZXRJbWFnZURhdGEoMCwwLGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0VGhyZWVKUygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0UG9zdCA9IGZ1bmN0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclNjZW5lID0gbmV3IFRIUkVFLlJlbmRlclBhc3MoIHNjZW5lLCBjYW1lcmEgKTtcclxuICAgICAgICAgICAgICAgIGxldCBibG9vbVBhc3MgPSBuZXcgVEhSRUUuVW5yZWFsQmxvb21QYXNzKCBuZXcgVEhSRUUuVmVjdG9yMiggd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCApLCAxLjUsIDAuNCwgMC44NSApO1xyXG4gICAgICAgICAgICAgICAgYmxvb21QYXNzLnRocmVzaG9sZCA9IHBhcmFtcy5ibG9vbVRocmVzaG9sZDtcclxuICAgICAgICAgICAgICAgIGJsb29tUGFzcy5zdHJlbmd0aCA9IHBhcmFtcy5ibG9vbVN0cmVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYmxvb21QYXNzLnJhZGl1cyA9IHBhcmFtcy5ibG9vbVJhZGl1cztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgY29tcG9zZXIgPSBuZXcgVEhSRUUuRWZmZWN0Q29tcG9zZXIoIHJlbmRlcmVyICk7XHJcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XHJcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5hZGRQYXNzKCByZW5kZXJTY2VuZSApO1xyXG4gICAgICAgICAgICAgICAgY29tcG9zZXIuYWRkUGFzcyggYmxvb21QYXNzICk7XHJcbiAgICAgICAgICAgIH0sMTUwMCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuaW5pdFRocmVlSlMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmlkID0gJ3RocmVlanNEaXYnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDEsIDMwMDApO1xyXG4gICAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IDEwMDA7XHJcbiAgICAgICAgICAgIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAgICAgICAgICAgIHNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKDB4MDAwMDAwLCAwLjAwMDUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7YW50aWFsaWFzOiB0cnVlLCBhbHBoYTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDEpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDAwMDAwMCwgMCk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHN0YXRzID0gbmV3IFN0YXRzKCk7XHJcbiAgICAgICAgICAgIC8vY29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXRzLmRvbSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUsIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaFN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uRG9jdW1lbnRUb3VjaE1vdmUsIGZhbHNlKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluaXRQb3N0KCk7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG4gICAgICAgICAgICBnZW9tID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgICAgICAvL2xldCB0MmRfcG9pbnQgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoICdwb2ludC5wbmcnKVxyXG5cclxuICAgICAgICAgICAgLy90aGlzLkdlbnJhdGVHZW9tKGdlb20pO1xyXG4gICAgICAgICAgICBHZW5yYXRlV2F2ZXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2NlbmUuYWRkKG5ldyBUSFJFRS5Qb2ludHMoIG5ldyBUSFJFRS5UZXh0R2VvbWV0cnkoJ1RocmVlanMgSGVsbG8gV29scmQnKSwgbWF0KSk7XHJcblxyXG5cclxuICAgICAgICAgICAgR2VucmF0ZUFyb3VuZCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpZ2h0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgbGlnaHRzWzBdID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDEpO1xyXG4gICAgICAgICAgICBsaWdodHNbMF0ucG9zaXRpb24uc2V0KDEsIDAsIDApO1xyXG4gICAgICAgICAgICBsaWdodHNbMV0gPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweDExRThCQiwgMSk7XHJcbiAgICAgICAgICAgIGxpZ2h0c1sxXS5wb3NpdGlvbi5zZXQoMC43NSwgMSwgMC41KTtcclxuICAgICAgICAgICAgbGlnaHRzWzJdID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHg4MjAwQzksIDEpO1xyXG4gICAgICAgICAgICBsaWdodHNbMl0ucG9zaXRpb24uc2V0KC0wLjc1LCAtMSwgMC41KTtcclxuICAgICAgICAgICAgc2NlbmUuYWRkKGxpZ2h0c1swXSk7XHJcbiAgICAgICAgICAgIHNjZW5lLmFkZChsaWdodHNbMV0pO1xyXG4gICAgICAgICAgICBzY2VuZS5hZGQobGlnaHRzWzJdKTtcclxuXHJcbiAgICAgICAgICAgIGFuaW1hdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIElzVHJhbnNwYXJlbnQoeCwgeSkge1xyXG4gICAgICAgICAgICBsZXQgdG90YWwgPSBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0ICogNDtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdG90YWwgLSAoeCAqIGNhbnZhcy5oZWlnaHQgKiA0KSArICh5ICogNCk7XHJcbiAgICAgICAgICAgIHJldHVybiAocGFyc2VJbnQoaW1nRGF0YS5kYXRhW2luZGV4ICsgM10pICE9IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gR2V0VmVjQ29sb3IoeCwgeSkge1xyXG4gICAgICAgICAgICBsZXQgdG90YWwgPSBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0ICogNDtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdG90YWwgLSAoeCAqIGNhbnZhcy5oZWlnaHQgKiA0KSArICh5ICogNCk7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcihpbWdEYXRhLmRhdGFbaW5kZXhdIC8gMjU1LCBpbWdEYXRhLmRhdGFbaW5kZXggKyAxXSAvIDI1NSwgaW1nRGF0YS5kYXRhW2luZGV4ICsgMl0gLyAyNTUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gR2VucmF0ZUFyb3VuZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDUwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LnggPSBNYXRoLnJhbmRvbSgpICogMjAwMCAtIDEwMDA7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueSA9IE1hdGgucmFuZG9tKCkgKiAyMDAwIC0gMTAwMDtcclxuICAgICAgICAgICAgICAgIHZlcnRleC56ID0gTWF0aC5yYW5kb20oKSAqIDIwMTAgLSAxMDAwO1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzLnB1c2goMS4wLCAxLjAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBbXHJcbiAgICAgICAgICAgICAgICBbWzEsIDEsIDAuNV0sICAgIDVdLFxyXG4gICAgICAgICAgICAgICAgW1swLjk1LCAxLCAwLjVdLCA4XSxcclxuICAgICAgICAgICAgICAgIFtbMC45MCwgMSwgMC41XSwgOF0sXHJcbiAgICAgICAgICAgICAgICBbWzAuODUsIDEsIDAuNV0sIDhdLFxyXG4gICAgICAgICAgICAgICAgW1swLjgwLCAxLCAwLjVdLCA4XVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsZXQgbG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcclxuICAgICAgICAgICAgbGV0IHQyZCA9IGxvYWRlci5sb2FkKCdzdGF0aWMvaW1nL3BvaW50MS5wbmcnKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9jb2xvciA9IC8vIFtNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1XTtcclxuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLnJhbmRvbSgpICogMTAgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsc1tpXSA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbChcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OnRydWUsIC8v5L2/5p2Q6LSo6YCP5piOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nOlRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoVGVzdDpmYWxzZSwgLy/mt7HluqbmtYvor5XlhbPpl63vvIzkuI3mtojljrvlnLrmma/nmoTkuI3lj6/op4FcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOnQyZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcnRpY2xlcyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsc1tpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcGFydGljbGVzLnJvdGF0aW9uLnggPSBNYXRoLnJhbmRvbSgpICogMDtcclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlcy5yb3RhdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIDY7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXMucm90YXRpb24ueiA9IE1hdGgucmFuZG9tKCkgKiA2O1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlcy5uYW1lID0gJ2Fyb3VuZCc7XHJcbiAgICAgICAgICAgICAgICBzY2VuZS5hZGQocGFydGljbGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gR2VucmF0ZVdhdmVzKCkge1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcnRpbGVfZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIDEsIDMyLCAxNiApO1xyXG4gICAgICAgICAgICBsZXQgdGVtcF9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQigxNTIsMjE1LDIzMyk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wX21hdCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCB7IGNvbG9yOnRlbXBfY29sb3IgfSApO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIGxldCB0MmQgPSBsb2FkZXIubG9hZCgnc3RhdGljL2ltZy9wb2ludDEucG5nJyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaV93YXZlID0gMDtcclxuICAgICAgICAgICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCBBTU9VTlRYOyBpeCsrICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggbGV0IGl5ID0gMDsgaXkgPCBBTU9VTlRZOyBpeSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wX3Nwcml0ZV9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQigxMjUsMjUzLDI1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGVyaWFsX3dhdmUgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXA6IHQyZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlU2NyZWVuQ29vcmRpbmF0ZXM6IGZhbHNlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRlbXBfc3ByaXRlX2NvbG9yLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2F2ZV9jb29yZC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzICggaXggKiBTRVBBUkFUSU9OIC0gKChBTU9VTlRYICogU0VQQVJBVElPTikgLyAyKSwgLTUwMCxpeSAqIFNFUEFSQVRJT04gLSAoKEFNT1VOVFkgKiBTRVBBUkFUSU9OKSAvIDIpICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sbG93X3BhcnRpY2xlID0gbmV3IFRIUkVFLlNwcml0ZShtYXRlcmlhbF93YXZlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGljbGVfbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBwYXJ0aWxlX2dlb21ldHJ5LCB0ZW1wX21hdCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUgPSBwYXJ0aWNsZXNfd2F2ZVtpX3dhdmUrK10gPSBwYXJ0aWNsZV9tZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiA5MDAwIC0gNDUwMDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZV93YXZlLnBvc2l0aW9uLnogPSBNYXRoLnJhbmRvbSgpICogOTAwMCAtIDQ1MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIDkwMDAgLSA0NTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZV93YXZlLnNjYWxlLnggPSBwYXJ0aWNsZV93YXZlLnNjYWxlLnkgPSBNYXRoLnJhbmRvbSgpICogNSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93X3BhcnRpY2xlLnNjYWxlLnNldCgyLjQsIDIuNCwgMi40KTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZV93YXZlLmFkZChmb2xsb3dfcGFydGljbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbGV0IHBhcnRpY2xlX21lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmFkZChwYXJ0aWNsZV93YXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlfd2F2ZSA+IDApIFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlfd2F2ZS52ZXJ0aWNlcy5wdXNoKHBhcnRpY2xlX3dhdmUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwYXJ0aWNsZV93YXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuR2VucmF0ZUdlb20gPSBmdW5jdGlvbiAoX2dlb20pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wX3N1YkhlaWdodCA9ICAoY2FudmFzLmhlaWdodCA8IDI1MCA/IGNhbnZhcy5oZWlnaHQgKiAxLjUgOiBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoeSAtIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLSBjYW52YXMuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwMCAtIHRlbXBfc3ViSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZlY19yYW5kb20gPSBuZXcgVEhSRUUuVmVjdG9yMyggTWF0aC5yYW5kb20oKSAqIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggKiA0IC0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICogNCAtIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogNDAwMCAtIDIwMDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoSXNUcmFuc3BhcmVudCh4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBHZXRWZWNDb2xvcih4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZW9tLnZlcnRpY2VzLnB1c2godmVjX3JhbmRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZW9tLmNvbG9ycy5wdXNoKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nQ29vcmQucHVzaCh2ZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdWZWNDb2xvci5wdXNoKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9nZW9tLmNlbnRlcigpO1xyXG5cclxuICAgICAgICAgICAgbWF0ID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtzaXplOiAyLCB2ZXJ0ZXhDb2xvcnM6IHRydWV9KTtcclxuICAgICAgICAgICAgbGV0IGNsb3VkID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tLCBtYXQpO1xyXG5cclxuICAgICAgICAgICAgY2xvdWQubmFtZSA9ICdJbWFnZVBhcnRpY2xlJztcclxuICAgICAgICAgICAgY2xvdWQucm90YXRpb24ueSA9IE1hdGguUEkgKiAxLjg7XHJcbiAgICAgICAgICAgIHNjZW5lLmFkZChjbG91ZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnR3ZWVuQW5pbSA9IGZ1bmN0aW9uIHR3ZWVuT2JqKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9tLnZlcnRpY2VzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkdlbnJhdGVHZW9tKGdlb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGksIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0d2VlbklucyA9IG5ldyBUV0VFTi5Ud2VlbihlKS50byhcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW1nQ29vcmRbaV0ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGltZ0Nvb3JkW2ldLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1hdGgucmFuZG9tKCkgKiA3NTAgKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KE1hdGgucmFuZG9tKCkgKiAyNTAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbklucy5zdGFydCgpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5BbmltMSA9IGZ1bmN0aW9uIHR3ZWVuT2JqKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGdlb20udmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSwgYXJyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgKiAxMDAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR3ZWVuSW5zID0gbmV3IFRXRUVOLlR3ZWVuKGUpLnRvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbWdDb29yZFtpXS54ICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbWdDb29yZFtpXS55ICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56ICogMiA+IDEwMDAgPyBlLnogKiAyIDogMTAwMS8vZS56XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1hdGgucmFuZG9tKCkgKiA3NTAgKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KE1hdGgucmFuZG9tKCkgKiAyNTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuSW5zLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy50d2VlbkFuaW0yID0gZnVuY3Rpb24gdHdlZW5PYmooaW5kZXgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgc2NlbmVJdGVtIG9mIHNjZW5lLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUl0ZW0ubmFtZSA9IFwiSW1hZ2VQYXJ0aWNsZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2NlbmVJdGVtIG9mIHNjZW5lLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NlbmVJdGVtLm1hdGVyaWFsLnNpemUgPSAyLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDE1MDApO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSwgYXJyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHdlZW5JbnMgPSBuZXcgVFdFRU4uVHdlZW4oZSkudG8oXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbWdDb29yZFtpXS54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbWdDb29yZFtpXS55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56Ly9lLnpcclxuICAgICAgICAgICAgICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogNTAwKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5JbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoTWF0aC5yYW5kb20oKSAqIDUwMClcclxuICAgICAgICAgICAgICAgICAgICAub25VcGRhdGUoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc1tpXSA9IGltZ1ZlY0NvbG9yW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHR3ZWVuSW5zLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5BbmltMyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGJmbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IGJXYXZlc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xyXG4gICAgICAgICAgICB3aW5kb3dIYWxmWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcclxuICAgICAgICAgICAgd2luZG93SGFsZlkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG1vdXNlWCA9IGV2ZW50LmNsaWVudFggLSB3aW5kb3dIYWxmWDtcclxuICAgICAgICAgICAgbW91c2VZID0gZXZlbnQuY2xpZW50WSAtIHdpbmRvd0hhbGZZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgbW91c2VYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvd0hhbGZYO1xyXG4gICAgICAgICAgICAgICAgbW91c2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvd0hhbGZZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIG1vdXNlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3dIYWxmWDtcclxuICAgICAgICAgICAgICAgIG1vdXNlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3dIYWxmWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgICAgICBUV0VFTi51cGRhdGUodGltZSk7XHJcbiAgICAgICAgICAgIHJlbmRlcigpO1xyXG4gICAgICAgICAgICBzdGF0cy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAqIDAuMDAwMDU7XHJcblxyXG4gICAgICAgICAgICBpZiAoKChtb3VzZVggLSBjYW1lcmEucG9zaXRpb24ueCkgPiAwICYmIGNhbWVyYS5wb3NpdGlvbi54IDwgIDUwKSB8fFxyXG4gICAgICAgICAgICAgICAgKChtb3VzZVggLSBjYW1lcmEucG9zaXRpb24ueCkgPCAwICYmIGNhbWVyYS5wb3NpdGlvbi54ID4gLTUwKSkge1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKG1vdXNlWCAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoKG1vdXNlWSAtIGNhbWVyYS5wb3NpdGlvbi55KSA+IDAgJiYgY2FtZXJhLnBvc2l0aW9uLnkgPCA1MCkgfHxcclxuICAgICAgICAgICAgICAgICgobW91c2VZIC0gY2FtZXJhLnBvc2l0aW9uLnkpIDwgMCAmJiBjYW1lcmEucG9zaXRpb24ueSA+IC01MCkpIHtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9IChtb3VzZVkgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjAwNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBnZW9tLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb20uY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJlbmRlcl9hcm91bmQodGltZSk7XHJcbiAgICAgICAgICAgIHJlbmRlcl93YXZlKCk7XHJcbiAgICAgICAgICAgIC8vZm9yICggaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xyXG4gICAgICAgICAgICAvL1x0Y29sb3IgPSBwYXJhbWV0ZXJzW2ldWzBdO1xyXG4gICAgICAgICAgICAvL1x0aCA9ICggMzYwICogKCBjb2xvclswXSArIHRpbWUgKSAlIDM2MCApIC8gMzYwO1xyXG4gICAgICAgICAgICAvL1x0bWF0ZXJpYWxzW2ldLmNvbG9yLnNldEhTTCggaCwgY29sb3JbMV0sIGNvbG9yWzJdICk7XHJcbiAgICAgICAgICAgIC8vfVxyXG5cclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xyXG4gICAgICAgICAgICBjb3VudF93YXZlICs9IDAuMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcl9hcm91bmQodGltZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBpX2Fyb3VuZCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NlbmUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBzY2VuZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSA9PT0gJ2Fyb3VuZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJvdGF0aW9uLnkgPSB0aW1lICogKGlfYXJvdW5kIDwgNCA/IGlfYXJvdW5kICsgMSA6IC0oaV9hcm91bmQgKyAxKSkgKiAyLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgaV9hcm91bmQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5uYW1lID09PSAnSW1hZ2VQYXJ0aWNsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnJvdGF0aW9uLnkgPCA2LjI4MzE4KSBcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi55ICs9IE1hdGguUEkgLyAxODAgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmZsYWcpIFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cob2JqZWN0LnJvdGF0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRpb24ueSA9IDYuMjgzMTg1MzA3MTc5NTg2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUaHJlZUlucy50d2VlbkFuaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcl93YXZlKCkge1xyXG4gICAgICAgICAgICBsZXQgaV93YXZlID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICgocGFydGljbGVzX3dhdmUubGVuZ3RoID4gQU1PVU5UWCAqIEFNT1VOVFkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggYldhdmVzaW5nICApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8qKndhdmVzICovXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgQU1PVU5UWDsgaXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGl5ID0gMDsgaXkgPCBBTU9VTlRZOyBpeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eCA9IGl4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHkgPSBpeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUgPSBwYXJ0aWNsZXNfd2F2ZVtpX3dhdmUrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wYXJ0aWNsZV93YXZlLnBvc2l0aW9uLnkgID0gLy9wYXJ0aWNsZV93YXZlLnBvc2l0aW9uLnkgKyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNYXRoLnNpbiggKCBpeCArIGNvdW50X3dhdmUgKSAqIDAuMyApICogNTAgKSArICggTWF0aC5zaW4oICggaXkgKyBjb3VudF93YXZlICkgKiAwLjQgKSAqIDUwICkgLSA1MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueSA9IHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueSArIE1hdGguc2luKCh0eCArIGNvdW50X3dhdmUpICogMC4zKSAqIDIgKyAoTWF0aC5zaW4oKHR5ICsgY291bnRfd2F2ZSkgKiAwLjUpKSAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUuc2NhbGUueCA9IHBhcnRpY2xlX3dhdmUuc2NhbGUueSA9IChNYXRoLnNpbigodHggKyBjb3VudF93YXZlKSAqIDAuMykgKyAxKSAqIDIuNSArIChNYXRoLnNpbigodHkgKyBjb3VudF93YXZlKSAqIDAuNSkgKyAxKSAqIDIuNTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBcclxuICAgICAgICAgICAgeyAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKCFiaXNOKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBBTU9VTlRYOyBpeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGl5ID0gMDsgaXkgPCBBTU9VTlRZOyBpeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUgPSBwYXJ0aWNsZXNfd2F2ZVtpX3dhdmUrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcF9yYWQgPSBNYXRoLnJhbmRvbSgpICogMC4wNSArIDAuMDEgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi54ID0gcGFydGljbGVfd2F2ZS5wb3NpdGlvbi56ICogTWF0aC5zaW4odGVtcF9yYWQpICsgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi54ICogTWF0aC5jb3ModGVtcF9yYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi56ID0gcGFydGljbGVfd2F2ZS5wb3NpdGlvbi56ICogTWF0aC5jb3ModGVtcF9yYWQpIC0gcGFydGljbGVfd2F2ZS5wb3NpdGlvbi54ICogTWF0aC5zaW4odGVtcF9yYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy90ZXgrPSAwLjE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGhyZWVJbnM7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/main.js\n");

/***/ })

/******/ });