/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet ThreeIns;\r\n\r\n\r\n\r\nwindow.onload = function()\r\n{\r\n    ThreeIns = new ThreeJsClass();\r\n    window.ThreeIns = ThreeIns;\r\n}\r\n//test \r\n\r\n\r\n\r\n\tfunction ThreeJsClass() {\r\n        if (!Detector.webgl) {\r\n            Detector.addGetWebGLMessage()\r\n        };\r\n\r\n        setTimeout(() => {\r\n            let maxTime = 0;\r\n            bisN = true;\r\n            particles_wave.forEach(function (e,i,arr)\r\n            {\r\n                let time_exec = Math.random() * 500 + 500 ;\r\n                let time_delay = Math.random() * 300 ;\r\n                maxTime =( maxTime > time_exec + time_delay ?maxTime :time_exec + time_delay );\r\n                let tweenIns = new TWEEN.Tween(e.position).to(\r\n                    {\r\n                        x:wave_coord[i].x, \r\n                        y:wave_coord[i].y,\r\n                        z:wave_coord[i].z\r\n                    },time_exec).easing(TWEEN.Easing.Quadratic.InOut).delay(time_delay);\r\n                tweenIns.start();\r\n            });\r\n\r\n            setTimeout(() => {\r\n                bWavesing = true;\r\n            }, maxTime - 200);\r\n        }, 1000);\r\n\r\n        let container, stats;\r\n        let camera, scene, renderer, geometry, materials = [], parameters, i, h, color, size;\r\n        let mouseX = 0, mouseY = 0;\r\n        let windowHalfX = window.innerWidth / 2;\r\n        let windowHalfY = window.innerHeight / 2;\r\n\r\n        let geom;\r\n        let mat;\r\n\r\n        let bflag = true;\r\n        let bWavesing = false;\r\n        let bisN = false;\r\n        let clock = new THREE.Clock();\r\n\r\n        /**\r\n         * 辉光\r\n         * */\r\n\r\n        let composer, mixer;\r\n        let params = {\r\n            exposure: 2,\r\n            bloomStrength: 2,\r\n            bloomThreshold: 0,\r\n            bloomRadius: 0\r\n        };\r\n\r\n        /**\r\n         * 辉光\r\n         */\r\n         \r\n        /**\r\n         * 波浪 start\r\n         */\r\n\r\n        const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;\r\n        let particles_wave = new Array();\r\n        let particle_wave;\r\n        let geometry_wave = new THREE.Geometry();\r\n        let count_wave = 1;\r\n        let wave_coord = new Array();\r\n        \r\n        /**\r\n         * 波浪 end\r\n         */\r\n\r\n         /**\r\n         *  smoke start \r\n         */\r\n\r\n\r\n        let smoke_particles = [];\r\n\r\n\r\n        /**\r\n         *  smoke end \r\n         */\r\n\r\n\r\n        /**\r\n         * img 数据 start\r\n         */\r\n        let canvas = document.createElement('canvas');\r\n        let content = canvas.getContext('2d');\r\n        let img = new Image();\r\n        let imgData ;\r\n        img.src = \"static/img/5.png\";\r\n        canvas.style.position = 'absolute';\r\n\r\n        if (window.innerWidth > 720)\r\n        {\r\n            canvas.width = 250;\r\n            canvas.height = 250;\r\n        }\r\n        else \r\n        {\r\n            canvas.width = 200;\r\n            canvas.height = 200;\r\n        }\r\n\r\n        \r\n        canvas.style.display = 'none';\r\n\r\n        let imgCoord = [];\r\n        let imgVecColor = [];\r\n        /**\r\n         * img 数据 end\r\n         */\r\n\r\n        this.init = function()\r\n        {\r\n            let _this = this;\r\n            img.onload = function () {\r\n                content.drawImage(img, 0, 0 ,canvas.width, canvas.height);\r\n                imgData = content.getImageData(0,0,canvas.width, canvas.height);\r\n                _this.initThreeJS();\r\n            };\r\n        }\r\n\r\n        this.initPost = function()\r\n        {\r\n            console.log('init postprocess');\r\n\r\n            composer = new THREE.EffectComposer( renderer );\r\n            console.log(composer);\r\n            composer.setSize( window.innerWidth, window.innerHeight );\r\n            let pass = new THREE.RenderPass( scene, camera );\r\n            composer.addPass(  pass );\r\n\r\n            \r\n            let pass1 = new THREE.ShaderPass(THREE.SepiaShader);\r\n            composer.addPass( pass1 );\r\n            pass1.renderToScene = true;\r\n        }\r\n\r\n\r\n        this.initThreeJS = function () {\r\n\r\n            container = document.createElement('div');\r\n            container.id = 'threejsDiv';\r\n\r\n            document.body.appendChild(container);\r\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);\r\n            camera.position.z = 1000;\r\n            scene = new THREE.Scene();\r\n            scene.fog = new THREE.FogExp2(0x000000, 0.0005);\r\n\r\n\r\n            console.log(renderer);\r\n            renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\r\n            renderer.setPixelRatio((window.devicePixelRatio) ? window.devicePixelRatio : 1);\r\n            renderer.autoClear = false;\r\n            renderer.setClearColor(0x000000, 0);\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n            container.appendChild(renderer.domElement);\r\n            stats = new Stats();\r\n            //container.appendChild(stats.dom);\r\n            document.addEventListener('mousemove',  onDocumentMouseMove,    false);\r\n            document.addEventListener('touchstart', onDocumentTouchStart,   false);\r\n            document.addEventListener('touchmove',  onDocumentTouchMove,    false);\r\n            window.addEventListener  ('resize',     onWindowResize,         false);\r\n\r\n            this.initPost();\r\n\r\n            geometry = new THREE.Geometry();\r\n            geom = new THREE.Geometry();\r\n\r\n            GenrateWaves();\r\n            //GenrateSmoke();\r\n            GenrateAround();\r\n            var lights = [];\r\n\r\n            lights[0] = new THREE.DirectionalLight(0xffffff, 1);\r\n            lights[0].position.set(1, 0, 0);\r\n            lights[1] = new THREE.DirectionalLight(0x11E8BB, 1);\r\n            lights[1].position.set(0.75, 1, 0.5);\r\n            lights[2] = new THREE.DirectionalLight(0x8200C9, 1);\r\n            lights[2].position.set(-0.75, -1, 0.5);\r\n            scene.add(lights[0]);\r\n            scene.add(lights[1]);\r\n            scene.add(lights[2]);\r\n\r\n            animate();\r\n\r\n        }\r\n\r\n        function IsTransparent(x, y) {\r\n            let total = canvas.width * canvas.height * 4;\r\n            let index = total - (x * canvas.height * 4) + (y * 4);\r\n            return (parseInt(imgData.data[index + 3]) != 0);\r\n        }\r\n\r\n        function GetVecColor(x, y) {\r\n            let total = canvas.width * canvas.height * 4;\r\n            let index = total - (x * canvas.height * 4) + (y * 4);\r\n            let color = new THREE.Color(imgData.data[index] / 255, imgData.data[index + 1] / 255, imgData.data[index + 2] / 255);\r\n            return color;\r\n        }\r\n\r\n        function GenrateSmoke()\r\n        {\r\n\r\n            let loader = new THREE.TextureLoader();\r\n            let smoke_t2d =  loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/95637/Smoke-Element.png');\r\n            let smoke_mat = new THREE.MeshLambertMaterial({color: 0x00ffff, map: smoke_t2d, transparent: true});\r\n            \r\n            let textT2d = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/95637/quickText.png');\r\n            let text_mat = new THREE.MeshLambertMaterial({color: 0x00ffff, opacity: 1, map: textT2d, transparent: true, blending: THREE.AdditiveBlending});\r\n            let smoke_geo = new THREE.PlaneGeometry(500,500);\r\n\r\n            for (let p = 0; p < 50; p++) {\r\n                let tempMesh =new THREE.Mesh(smoke_geo,smoke_mat);\r\n                tempMesh.position.set( Math.random() * 1000 - 500,\r\n                                       Math.random() * 1000 - 500,\r\n                                       Math.random() * 500 );\r\n                tempMesh.rotation.z =  Math.random() * 360;\r\n                smoke_particles.push(tempMesh);\r\n                scene.add(tempMesh);\r\n                //tempMesh.lookAt(camera.position);\r\n                \r\n            }\r\n        \r\n            \r\n        }\r\n\r\n        function GenrateAround()\r\n        {\r\n            \r\n            for (i = 0; i < 50; i++) {\r\n                var vertex = new THREE.Vector3();\r\n                vertex.x = Math.random() * 2000 - 1000;\r\n                vertex.y = Math.random() * 2000 - 1000;\r\n                vertex.z = Math.random() * 2010 - 1000;\r\n                geometry.vertices.push(vertex);\r\n                geometry.colors.push(1.0, 1.0, 1.0);\r\n            }\r\n\r\n            parameters = [\r\n                [[1, 1, 0.5],    5],\r\n                [[0.95, 1, 0.5], 8],\r\n                [[0.90, 1, 0.5], 8],\r\n                [[0.85, 1, 0.5], 8],\r\n                [[0.80, 1, 0.5], 8]\r\n            ];\r\n            let loader = new THREE.TextureLoader();\r\n            let t2d = loader.load('static/img/point1.png');\r\n            for (i = 0; i < 5; i++) {\r\n                //color = // [Math.random() * 255, Math.random() * 255, Math.random() * 255, Math.random() * 255];\r\n                size = Math.random() * 10 + 1;\r\n\r\n                materials[i] = new THREE.PointsMaterial(\r\n                    {\r\n                        transparent:true, //使材质透明\r\n                        blending:THREE.AdditiveBlending, //\r\n                        depthTest:false, //深度测试关闭，不消去场景的不可见\r\n                        size: size,\r\n                        map:t2d\r\n                    });\r\n                let particles = new THREE.Points(geometry, materials[i]);\r\n\r\n                particles.rotation.x = Math.random() * 0;\r\n                particles.rotation.y = Math.random() * 6;\r\n                particles.rotation.z = Math.random() * 6;\r\n\r\n                particles.name = 'around';\r\n                scene.add(particles);\r\n            }\r\n        }\r\n\r\n        function GenrateWaves() {\r\n\r\n            let partile_geometry = new THREE.SphereGeometry( 1, 32, 16 );\r\n            //let temp_color = new THREE.Color().setRGB(152,215,233);\r\n            let temp_color = new THREE.Color().setRGB(244,244,244);\r\n            let temp_mat = new THREE.LineBasicMaterial( { color:temp_color } );\r\n\r\n            let loader = new THREE.TextureLoader();\r\n            let t2d = loader.load('static/img/point1.png');\r\n\r\n            let i_wave = 0;\r\n            for ( let ix = 0; ix < AMOUNTX; ix++ ) {\r\n                for ( let iy = 0; iy < AMOUNTY; iy++ ) {\r\n                    //let temp_sprite_color = new THREE.Color().setRGB(125,253,255);\r\n                    let temp_sprite_color = new THREE.Color().setRGB(0,253,255);\r\n                    let material_wave = new THREE.SpriteMaterial({\r\n                        map: t2d,\r\n                        //useScreenCoordinates: false, \r\n                        color: temp_sprite_color, \r\n                        transparent: true, \r\n                        blending: THREE.AdditiveBlending\r\n                    });\r\n\r\n                    wave_coord.push(new THREE.Vector3 ( ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2),  -500 ,iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2) ) );\r\n                    let follow_particle = new THREE.Sprite(material_wave);\r\n                    let particle_mesh = new THREE.Mesh( partile_geometry, temp_mat );\r\n                    particle_wave = particles_wave[i_wave++] = particle_mesh;\r\n                    \r\n                    particle_wave.position.x = Math.random() * 9000 - 4500;\r\n                    particle_wave.position.z = Math.random() * 9000 - 4500;\r\n                    particle_wave.position.y = Math.random() * 9000 - 4500;\r\n                    \r\n                    particle_wave.scale.x = particle_wave.scale.y = Math.random() * 5 + 1;\r\n                    follow_particle.scale.set(2.4, 2.4, 2.4);\r\n                    particle_wave.add(follow_particle);\r\n\r\n                    scene.add(particle_wave);\r\n\r\n                    if (i_wave > 0) \r\n                    {\r\n                        geometry_wave.vertices.push(particle_wave.position);\r\n                    }\r\n                }\r\n            }\r\n            console.log(particle_wave);\r\n        }\r\n\r\n        this.GenrateGeom = function (_geom) {\r\n            console.log(canvas.height);\r\n            let temp_subHeight =  (canvas.height < 250 ? canvas.height * 1.5 : canvas.height);\r\n            for (var x = 0; x < canvas.width; x++) {\r\n                for (var y = 0; y < canvas.height; y++) {\r\n                    let vec = new THREE.Vector3(y - canvas.width / 2,\r\n                                                x - canvas.height / 2,\r\n                                                1000 - temp_subHeight);\r\n\r\n                    let vec_random = new THREE.Vector3( Math.random() * document.body.clientWidth * 4 - document.body.clientWidth * 2,\r\n                                                        Math.random() * document.body.clientHeight * 4 - document.body.clientHeight * 2,\r\n                                                        Math.random() * 4000 - 2000);\r\n\r\n                    if (IsTransparent(x, y)) {\r\n                        let color = GetVecColor(x, y);\r\n\r\n                        _geom.vertices.push(vec_random);\r\n                        _geom.colors.push(color);\r\n                        imgCoord.push(vec);\r\n                        imgVecColor.push(color);\r\n                    } \r\n                }\r\n            }\r\n            _geom.center();\r\n\r\n            mat = new THREE.PointsMaterial({size: 2, vertexColors: true});\r\n            let cloud = new THREE.Points(geom, mat);\r\n\r\n            cloud.name = 'ImageParticle';\r\n            cloud.rotation.y = Math.PI * 1.8;\r\n            scene.add(cloud);\r\n        }\r\n\r\n        this.tweenAnim = function tweenObj(index) {\r\n            if (geom.vertices.length <= 0)\r\n            {\r\n                this.GenrateGeom(geom);\r\n            }\r\n            else \r\n            {\r\n\r\n                geom.vertices.forEach(function (e, i, arr) {\r\n                    let tweenIns = new TWEEN.Tween(e).to(\r\n                        {\r\n                            x: imgCoord[i].x,\r\n                            y: imgCoord[i].y,\r\n                            z: imgCoord[i].z\r\n                        }, Math.random() * 750 ).easing(TWEEN.Easing.Quadratic.InOut)\r\n                        .delay(Math.random() * 250 );\r\n                    tweenIns.start();\r\n    \r\n                });\r\n    \r\n            }\r\n\r\n        };\r\n\r\n        this.tweenAnim1 = function tweenObj(index) {\r\n            geom.vertices.forEach(function (e, i, arr) {\r\n\r\n                if (Math.random() * 100 > 0) {\r\n                    let tweenIns = new TWEEN.Tween(e).to(\r\n                        {\r\n                            x: imgCoord[i].x * 10,\r\n                            y: imgCoord[i].y * 10,\r\n                            z: imgCoord[i].z * 2 > 1000 ? e.z * 2 : 1001//e.z\r\n                        }, Math.random() * 750 ).easing(TWEEN.Easing.Quadratic.InOut)\r\n                        .delay(Math.random() * 250);\r\n                    tweenIns.start();\r\n                } else {\r\n\r\n\r\n                }\r\n\r\n            })\r\n\r\n        };\r\n\r\n\r\n        this.tweenAnim2 = function tweenObj(index) {\r\n            for (let sceneItem of scene.children) {\r\n                sceneItem.name = \"ImageParticle\";\r\n            }\r\n            setTimeout(() => {\r\n                for (let sceneItem of scene.children) {\r\n                    sceneItem.material.size = 2.5;\r\n                }\r\n            }, 1500);\r\n\r\n            geometry.vertices.forEach(function (e, i, arr) {\r\n                let tweenIns = new TWEEN.Tween(e).to(\r\n                    {\r\n                        x: imgCoord[i].x,\r\n                        y: imgCoord[i].y,\r\n                        z: imgCoord[i].z//e.z\r\n                    }, Math.random() * 500).easing(TWEEN.Easing.Quadratic.In)\r\n                    .delay(Math.random() * 500)\r\n                    .onUpdate(function (i) {\r\n                            geometry.colors[i] = imgVecColor[i];\r\n                        }\r\n                    );\r\n                tweenIns.start();\r\n            });\r\n        };\r\n\r\n        this.tweenAnim3 = function () {\r\n            let bflag = true;\r\n            let bWavesing = false;\r\n        };\r\n\r\n        function onWindowResize() {\r\n            windowHalfX = window.innerWidth / 2;\r\n            windowHalfY = window.innerHeight / 2;\r\n            camera.aspect = window.innerWidth / window.innerHeight;\r\n            camera.updateProjectionMatrix();\r\n            renderer.setSize(window.innerWidth, window.innerHeight);\r\n        }\r\n\r\n        function onDocumentMouseMove(event) {\r\n            mouseX = event.clientX - windowHalfX;\r\n            mouseY = event.clientY - windowHalfY;\r\n        }\r\n\r\n        function onDocumentTouchStart(event) {\r\n            if (event.touches.length === 1) {\r\n                event.preventDefault();\r\n                mouseX = event.touches[0].pageX - windowHalfX;\r\n                mouseY = event.touches[0].pageY - windowHalfY;\r\n            }\r\n        }\r\n\r\n        function onDocumentTouchMove(event) {\r\n            if (event.touches.length === 1) {\r\n                event.preventDefault();\r\n                mouseX = event.touches[0].pageX - windowHalfX;\r\n                mouseY = event.touches[0].pageY - windowHalfY;\r\n            }\r\n        }\r\n\r\n        //\r\n        function animate(time) {\r\n            requestAnimationFrame(animate);\r\n            TWEEN.update(time);\r\n            render();\r\n            stats.update();\r\n        }\r\n\r\n\r\n        function render() {\r\n            var time = Date.now() * 0.00005;\r\n\r\n            if (((mouseX - camera.position.x) > 0 && camera.position.x <  50) ||\r\n                ((mouseX - camera.position.x) < 0 && camera.position.x > -50)) {\r\n                camera.position.x += (mouseX - camera.position.x) * 0.002;\r\n            }\r\n            if (((mouseY - camera.position.y) > 0 && camera.position.y < 50) ||\r\n                ((mouseY - camera.position.y) < 0 && camera.position.y > -50)) {\r\n                camera.position.y += (mouseY - camera.position.y) * 0.005;\r\n            }\r\n            \r\n            camera.lookAt(scene.position);\r\n\r\n            geom.verticesNeedUpdate = true;\r\n            geom.colorsNeedUpdate = true;\r\n            geometry.verticesNeedUpdate = true;\r\n            geometry.colorsNeedUpdate = true;\r\n\r\n\r\n            render_around(time);\r\n            render_wave();\r\n            //render_smoke(time);\r\n\r\n            \r\n            //\r\n            //renderer.render(scene, camera);\r\n            //console.log(composer);\r\n            composer.render(clock.getDelta());\r\n        }\r\n\r\n        function render_smoke(time)\r\n        {\r\n            let delta = clock.getDelta();\r\n            for(let i =0;i < smoke_particles.length ;i++ )\r\n            {\r\n                 \r\n               // smoke_particles[i].rotation.x += 0.005;\r\n               // smoke_particles[i].rotation.y += 0.01;\r\n                //smoke_particles[i].position.set(Math.random() * Math.PI / 1080, Math.random() * Math.PI / 180, Math.random() * Math.PI / 180);\r\n                smoke_particles[i].rotation.z += Math.random() * delta * 0.1;\r\n                //smoke_particles[i].position.z =(Math.sin(0.5) * 500);\r\n\r\n            }\r\n        }\r\n\r\n        function render_around(time)\r\n        {\r\n            let i_around = 0;\r\n            for (let i = 0; i < scene.children.length; i++) {\r\n                var object = scene.children[i];\r\n                if (object.name === 'around' && object instanceof THREE.Points) {\r\n                    object.rotation.y = time * (i_around < 4 ? i_around + 1 : -(i_around + 1)) * 2.5;\r\n                    i_around++;\r\n                }\r\n                else if (object.name === 'ImageParticle') {\r\n                    if (object.rotation.y < 6.28318) \r\n                    {\r\n                        object.rotation.y += Math.PI / 180 * 2;\r\n                    } \r\n                    else if (bflag) \r\n                    {\r\n                        bflag = false;\r\n                        console.log(object.rotation.y);\r\n                        object.rotation.y = 6.283185307179586;\r\n                        ThreeIns.tweenAnim();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function render_wave() {\r\n            let i_wave = 0;\r\n\r\n            if ((particles_wave.length > AMOUNTX * AMOUNTY)) {\r\n                return;\r\n            }\r\n\r\n            if ( bWavesing  )\r\n            {\r\n                count_wave += 0.1;\r\n                /**waves */\r\n                for (let ix = 0; ix < AMOUNTX; ix++) {\r\n                    for (let iy = 0; iy < AMOUNTY; iy++) {\r\n                        let tx = ix;\r\n                        let ty = iy;\r\n\r\n                        particle_wave = particles_wave[i_wave++];\r\n                        \r\n                        particle_wave.position.y = particle_wave.position.y + Math.sin((tx + count_wave) * 0.3) * 1.5  + (Math.sin((ty + count_wave) * 0.5)) ;\r\n                        particle_wave.scale.x = particle_wave.scale.y = (Math.sin((tx + count_wave) * 0.3) + 1) * 2.5 + (Math.sin((ty + count_wave) * 0.5) + 1) * 2.5;\r\n                    }\r\n                }\r\n            }\r\n            else \r\n            {   \r\n                if (!bisN)\r\n                {\r\n                    for (let ix = 0; ix < AMOUNTX; ix++) {\r\n                        for (let iy = 0; iy < AMOUNTY; iy++) {\r\n                            \r\n                            particle_wave = particles_wave[i_wave++];\r\n                            let temp_rad = 0.05;//Math.random() * 0.05 + 0.01 ;\r\n\r\n                            particle_wave.position.x = particle_wave.position.z * Math.sin(temp_rad) + particle_wave.position.x * Math.cos(temp_rad);\r\n                            particle_wave.position.z = particle_wave.position.z * Math.cos(temp_rad) - particle_wave.position.x * Math.sin(temp_rad);\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n            //tex+= 0.1;\r\n        }\r\n\r\n        this.init();\r\n    }\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ThreeIns);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxtREFBbUQ7O0FBRTlHO0FBQ0EsMERBQTBELCtGQUErRjtBQUN6Sjs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtQkFBbUI7O0FBRTVFO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QywrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qyw0QkFBNEI7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCOzs7QUFHakI7O0FBRUEsYUFBYTs7QUFFYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMsb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELHdDQUF3QyxjQUFjOztBQUV0RDtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJZSx1RUFBUSIsImZpbGUiOiIuL3NyYy9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IFRocmVlSW5zO1xyXG5cclxuXHJcblxyXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICBUaHJlZUlucyA9IG5ldyBUaHJlZUpzQ2xhc3MoKTtcclxuICAgIHdpbmRvdy5UaHJlZUlucyA9IFRocmVlSW5zO1xyXG59XHJcbi8vdGVzdCBcclxuXHJcblxyXG5cclxuXHRmdW5jdGlvbiBUaHJlZUpzQ2xhc3MoKSB7XHJcbiAgICAgICAgaWYgKCFEZXRlY3Rvci53ZWJnbCkge1xyXG4gICAgICAgICAgICBEZXRlY3Rvci5hZGRHZXRXZWJHTE1lc3NhZ2UoKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbWF4VGltZSA9IDA7XHJcbiAgICAgICAgICAgIGJpc04gPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXJ0aWNsZXNfd2F2ZS5mb3JFYWNoKGZ1bmN0aW9uIChlLGksYXJyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZV9leGVjID0gTWF0aC5yYW5kb20oKSAqIDUwMCArIDUwMCA7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZV9kZWxheSA9IE1hdGgucmFuZG9tKCkgKiAzMDAgO1xyXG4gICAgICAgICAgICAgICAgbWF4VGltZSA9KCBtYXhUaW1lID4gdGltZV9leGVjICsgdGltZV9kZWxheSA/bWF4VGltZSA6dGltZV9leGVjICsgdGltZV9kZWxheSApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHR3ZWVuSW5zID0gbmV3IFRXRUVOLlR3ZWVuKGUucG9zaXRpb24pLnRvKFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDp3YXZlX2Nvb3JkW2ldLngsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OndhdmVfY29vcmRbaV0ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejp3YXZlX2Nvb3JkW2ldLnpcclxuICAgICAgICAgICAgICAgICAgICB9LHRpbWVfZXhlYykuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuSW5PdXQpLmRlbGF5KHRpbWVfZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgdHdlZW5JbnMuc3RhcnQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGJXYXZlc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sIG1heFRpbWUgLSAyMDApO1xyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICBsZXQgY29udGFpbmVyLCBzdGF0cztcclxuICAgICAgICBsZXQgY2FtZXJhLCBzY2VuZSwgcmVuZGVyZXIsIGdlb21ldHJ5LCBtYXRlcmlhbHMgPSBbXSwgcGFyYW1ldGVycywgaSwgaCwgY29sb3IsIHNpemU7XHJcbiAgICAgICAgbGV0IG1vdXNlWCA9IDAsIG1vdXNlWSA9IDA7XHJcbiAgICAgICAgbGV0IHdpbmRvd0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xyXG4gICAgICAgIGxldCB3aW5kb3dIYWxmWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIGxldCBnZW9tO1xyXG4gICAgICAgIGxldCBtYXQ7XHJcblxyXG4gICAgICAgIGxldCBiZmxhZyA9IHRydWU7XHJcbiAgICAgICAgbGV0IGJXYXZlc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBiaXNOID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOi+ieWFiVxyXG4gICAgICAgICAqICovXHJcblxyXG4gICAgICAgIGxldCBjb21wb3NlciwgbWl4ZXI7XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZXhwb3N1cmU6IDIsXHJcbiAgICAgICAgICAgIGJsb29tU3RyZW5ndGg6IDIsXHJcbiAgICAgICAgICAgIGJsb29tVGhyZXNob2xkOiAwLFxyXG4gICAgICAgICAgICBibG9vbVJhZGl1czogMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOi+ieWFiVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDms6Lmtaogc3RhcnRcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgY29uc3QgU0VQQVJBVElPTiA9IDEwMCwgQU1PVU5UWCA9IDUwLCBBTU9VTlRZID0gNTA7XHJcbiAgICAgICAgbGV0IHBhcnRpY2xlc193YXZlID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgbGV0IHBhcnRpY2xlX3dhdmU7XHJcbiAgICAgICAgbGV0IGdlb21ldHJ5X3dhdmUgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICBsZXQgY291bnRfd2F2ZSA9IDE7XHJcbiAgICAgICAgbGV0IHdhdmVfY29vcmQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDms6LmtaogZW5kXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgICAvKipcclxuICAgICAgICAgKiAgc21va2Ugc3RhcnQgXHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICBsZXQgc21va2VfcGFydGljbGVzID0gW107XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgc21va2UgZW5kIFxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaW1nIOaVsOaNriBzdGFydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBsZXQgaW1nRGF0YSA7XHJcbiAgICAgICAgaW1nLnNyYyA9IFwic3RhdGljL2ltZy81LnBuZ1wiO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDcyMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDI1MDtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDIwMDtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDIwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBsZXQgaW1nQ29vcmQgPSBbXTtcclxuICAgICAgICBsZXQgaW1nVmVjQ29sb3IgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpbWcg5pWw5o2uIGVuZFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICB0aGlzLmluaXQgPSBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudC5kcmF3SW1hZ2UoaW1nLCAwLCAwICxjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaW1nRGF0YSA9IGNvbnRlbnQuZ2V0SW1hZ2VEYXRhKDAsMCxjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdFRocmVlSlMoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdFBvc3QgPSBmdW5jdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW5pdCBwb3N0cHJvY2VzcycpO1xyXG5cclxuICAgICAgICAgICAgY29tcG9zZXIgPSBuZXcgVEhSRUUuRWZmZWN0Q29tcG9zZXIoIHJlbmRlcmVyICk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBvc2VyKTtcclxuICAgICAgICAgICAgY29tcG9zZXIuc2V0U2l6ZSggd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCApO1xyXG4gICAgICAgICAgICBsZXQgcGFzcyA9IG5ldyBUSFJFRS5SZW5kZXJQYXNzKCBzY2VuZSwgY2FtZXJhICk7XHJcbiAgICAgICAgICAgIGNvbXBvc2VyLmFkZFBhc3MoICBwYXNzICk7XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHBhc3MxID0gbmV3IFRIUkVFLlNoYWRlclBhc3MoVEhSRUUuU2VwaWFTaGFkZXIpO1xyXG4gICAgICAgICAgICBjb21wb3Nlci5hZGRQYXNzKCBwYXNzMSApO1xyXG4gICAgICAgICAgICBwYXNzMS5yZW5kZXJUb1NjZW5lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0aGlzLmluaXRUaHJlZUpTID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9ICd0aHJlZWpzRGl2JztcclxuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMzAwMCk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMTAwMDtcclxuICAgICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuICAgICAgICAgICAgc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZ0V4cDIoMHgwMDAwMDAsIDAuMDAwNSk7XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmVuZGVyZXIpO1xyXG4gICAgICAgICAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHthbnRpYWxpYXM6IHRydWUsIGFscGhhOiB0cnVlfSk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMSk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAwKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcclxuICAgICAgICAgICAgc3RhdHMgPSBuZXcgU3RhdHMoKTtcclxuICAgICAgICAgICAgLy9jb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgIG9uRG9jdW1lbnRNb3VzZU1vdmUsICAgIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaFN0YXJ0LCAgIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgIG9uRG9jdW1lbnRUb3VjaE1vdmUsICAgIGZhbHNlKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgICgncmVzaXplJywgICAgIG9uV2luZG93UmVzaXplLCAgICAgICAgIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFBvc3QoKTtcclxuXHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgIGdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcbiAgICAgICAgICAgIEdlbnJhdGVXYXZlcygpO1xyXG4gICAgICAgICAgICAvL0dlbnJhdGVTbW9rZSgpO1xyXG4gICAgICAgICAgICBHZW5yYXRlQXJvdW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBsaWdodHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGxpZ2h0c1swXSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcclxuICAgICAgICAgICAgbGlnaHRzWzBdLnBvc2l0aW9uLnNldCgxLCAwLCAwKTtcclxuICAgICAgICAgICAgbGlnaHRzWzFdID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHgxMUU4QkIsIDEpO1xyXG4gICAgICAgICAgICBsaWdodHNbMV0ucG9zaXRpb24uc2V0KDAuNzUsIDEsIDAuNSk7XHJcbiAgICAgICAgICAgIGxpZ2h0c1syXSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ODIwMEM5LCAxKTtcclxuICAgICAgICAgICAgbGlnaHRzWzJdLnBvc2l0aW9uLnNldCgtMC43NSwgLTEsIDAuNSk7XHJcbiAgICAgICAgICAgIHNjZW5lLmFkZChsaWdodHNbMF0pO1xyXG4gICAgICAgICAgICBzY2VuZS5hZGQobGlnaHRzWzFdKTtcclxuICAgICAgICAgICAgc2NlbmUuYWRkKGxpZ2h0c1syXSk7XHJcblxyXG4gICAgICAgICAgICBhbmltYXRlKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gSXNUcmFuc3BhcmVudCh4LCB5KSB7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQgKiA0O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0b3RhbCAtICh4ICogY2FudmFzLmhlaWdodCAqIDQpICsgKHkgKiA0KTtcclxuICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChpbWdEYXRhLmRhdGFbaW5kZXggKyAzXSkgIT0gMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBHZXRWZWNDb2xvcih4LCB5KSB7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQgKiA0O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0b3RhbCAtICh4ICogY2FudmFzLmhlaWdodCAqIDQpICsgKHkgKiA0KTtcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGltZ0RhdGEuZGF0YVtpbmRleF0gLyAyNTUsIGltZ0RhdGEuZGF0YVtpbmRleCArIDFdIC8gMjU1LCBpbWdEYXRhLmRhdGFbaW5kZXggKyAyXSAvIDI1NSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEdlbnJhdGVTbW9rZSgpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgbGV0IGxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIGxldCBzbW9rZV90MmQgPSAgbG9hZGVyLmxvYWQoJ2h0dHBzOi8vczMtdXMtd2VzdC0yLmFtYXpvbmF3cy5jb20vcy5jZHBuLmlvLzk1NjM3L1Ntb2tlLUVsZW1lbnQucG5nJyk7XHJcbiAgICAgICAgICAgIGxldCBzbW9rZV9tYXQgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7Y29sb3I6IDB4MDBmZmZmLCBtYXA6IHNtb2tlX3QyZCwgdHJhbnNwYXJlbnQ6IHRydWV9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB0ZXh0VDJkID0gbG9hZGVyLmxvYWQoJ2h0dHBzOi8vczMtdXMtd2VzdC0yLmFtYXpvbmF3cy5jb20vcy5jZHBuLmlvLzk1NjM3L3F1aWNrVGV4dC5wbmcnKTtcclxuICAgICAgICAgICAgbGV0IHRleHRfbWF0ID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2NvbG9yOiAweDAwZmZmZiwgb3BhY2l0eTogMSwgbWFwOiB0ZXh0VDJkLCB0cmFuc3BhcmVudDogdHJ1ZSwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmd9KTtcclxuICAgICAgICAgICAgbGV0IHNtb2tlX2dlbyA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDUwMCw1MDApO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCA1MDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcE1lc2ggPW5ldyBUSFJFRS5NZXNoKHNtb2tlX2dlbyxzbW9rZV9tYXQpO1xyXG4gICAgICAgICAgICAgICAgdGVtcE1lc2gucG9zaXRpb24uc2V0KCBNYXRoLnJhbmRvbSgpICogMTAwMCAtIDUwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDEwMDAgLSA1MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiA1MDAgKTtcclxuICAgICAgICAgICAgICAgIHRlbXBNZXNoLnJvdGF0aW9uLnogPSAgTWF0aC5yYW5kb20oKSAqIDM2MDtcclxuICAgICAgICAgICAgICAgIHNtb2tlX3BhcnRpY2xlcy5wdXNoKHRlbXBNZXNoKTtcclxuICAgICAgICAgICAgICAgIHNjZW5lLmFkZCh0ZW1wTWVzaCk7XHJcbiAgICAgICAgICAgICAgICAvL3RlbXBNZXNoLmxvb2tBdChjYW1lcmEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBHZW5yYXRlQXJvdW5kKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IE1hdGgucmFuZG9tKCkgKiAyMDAwIC0gMTAwMDtcclxuICAgICAgICAgICAgICAgIHZlcnRleC55ID0gTWF0aC5yYW5kb20oKSAqIDIwMDAgLSAxMDAwO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LnogPSBNYXRoLnJhbmRvbSgpICogMjAxMCAtIDEwMDA7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCgxLjAsIDEuMCwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFyYW1ldGVycyA9IFtcclxuICAgICAgICAgICAgICAgIFtbMSwgMSwgMC41XSwgICAgNV0sXHJcbiAgICAgICAgICAgICAgICBbWzAuOTUsIDEsIDAuNV0sIDhdLFxyXG4gICAgICAgICAgICAgICAgW1swLjkwLCAxLCAwLjVdLCA4XSxcclxuICAgICAgICAgICAgICAgIFtbMC44NSwgMSwgMC41XSwgOF0sXHJcbiAgICAgICAgICAgICAgICBbWzAuODAsIDEsIDAuNV0sIDhdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGxldCBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG4gICAgICAgICAgICBsZXQgdDJkID0gbG9hZGVyLmxvYWQoJ3N0YXRpYy9pbWcvcG9pbnQxLnBuZycpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbG9yID0gLy8gW01hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTVdO1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgucmFuZG9tKCkgKiAxMCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzW2ldID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6dHJ1ZSwgLy/kvb/mnZDotKjpgI/mmI5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmc6VEhSRUUuQWRkaXRpdmVCbGVuZGluZywgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhUZXN0OmZhbHNlLCAvL+a3seW6pua1i+ivleWFs+mXre+8jOS4jea2iOWOu+WcuuaZr+eahOS4jeWPr+ingVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXA6dDJkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFydGljbGVzID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWxzW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXMucm90YXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiAwO1xyXG4gICAgICAgICAgICAgICAgcGFydGljbGVzLnJvdGF0aW9uLnkgPSBNYXRoLnJhbmRvbSgpICogNjtcclxuICAgICAgICAgICAgICAgIHBhcnRpY2xlcy5yb3RhdGlvbi56ID0gTWF0aC5yYW5kb20oKSAqIDY7XHJcblxyXG4gICAgICAgICAgICAgICAgcGFydGljbGVzLm5hbWUgPSAnYXJvdW5kJztcclxuICAgICAgICAgICAgICAgIHNjZW5lLmFkZChwYXJ0aWNsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBHZW5yYXRlV2F2ZXMoKSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFydGlsZV9nZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggMSwgMzIsIDE2ICk7XHJcbiAgICAgICAgICAgIC8vbGV0IHRlbXBfY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoMTUyLDIxNSwyMzMpO1xyXG4gICAgICAgICAgICBsZXQgdGVtcF9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQigyNDQsMjQ0LDI0NCk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wX21hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjp0ZW1wX2NvbG9yIH0gKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG4gICAgICAgICAgICBsZXQgdDJkID0gbG9hZGVyLmxvYWQoJ3N0YXRpYy9pbWcvcG9pbnQxLnBuZycpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGlfd2F2ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoIGxldCBpeCA9IDA7IGl4IDwgQU1PVU5UWDsgaXgrKyApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIGxldCBpeSA9IDA7IGl5IDwgQU1PVU5UWTsgaXkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2xldCB0ZW1wX3Nwcml0ZV9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQigxMjUsMjUzLDI1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBfc3ByaXRlX2NvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKDAsMjUzLDI1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGVyaWFsX3dhdmUgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXA6IHQyZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91c2VTY3JlZW5Db29yZGluYXRlczogZmFsc2UsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGVtcF9zcHJpdGVfY29sb3IsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdhdmVfY29vcmQucHVzaChuZXcgVEhSRUUuVmVjdG9yMyAoIGl4ICogU0VQQVJBVElPTiAtICgoQU1PVU5UWCAqIFNFUEFSQVRJT04pIC8gMiksICAtNTAwICxpeSAqIFNFUEFSQVRJT04gLSAoKEFNT1VOVFkgKiBTRVBBUkFUSU9OKSAvIDIpICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sbG93X3BhcnRpY2xlID0gbmV3IFRIUkVFLlNwcml0ZShtYXRlcmlhbF93YXZlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGljbGVfbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBwYXJ0aWxlX2dlb21ldHJ5LCB0ZW1wX21hdCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUgPSBwYXJ0aWNsZXNfd2F2ZVtpX3dhdmUrK10gPSBwYXJ0aWNsZV9tZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiA5MDAwIC0gNDUwMDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZV93YXZlLnBvc2l0aW9uLnogPSBNYXRoLnJhbmRvbSgpICogOTAwMCAtIDQ1MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIDkwMDAgLSA0NTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUuc2NhbGUueCA9IHBhcnRpY2xlX3dhdmUuc2NhbGUueSA9IE1hdGgucmFuZG9tKCkgKiA1ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBmb2xsb3dfcGFydGljbGUuc2NhbGUuc2V0KDIuNCwgMi40LCAyLjQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUuYWRkKGZvbGxvd19wYXJ0aWNsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmFkZChwYXJ0aWNsZV93YXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlfd2F2ZSA+IDApIFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlfd2F2ZS52ZXJ0aWNlcy5wdXNoKHBhcnRpY2xlX3dhdmUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwYXJ0aWNsZV93YXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuR2VucmF0ZUdlb20gPSBmdW5jdGlvbiAoX2dlb20pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wX3N1YkhlaWdodCA9ICAoY2FudmFzLmhlaWdodCA8IDI1MCA/IGNhbnZhcy5oZWlnaHQgKiAxLjUgOiBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoeSAtIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLSBjYW52YXMuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwMCAtIHRlbXBfc3ViSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZlY19yYW5kb20gPSBuZXcgVEhSRUUuVmVjdG9yMyggTWF0aC5yYW5kb20oKSAqIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggKiA0IC0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICogNCAtIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogNDAwMCAtIDIwMDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoSXNUcmFuc3BhcmVudCh4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBHZXRWZWNDb2xvcih4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZW9tLnZlcnRpY2VzLnB1c2godmVjX3JhbmRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nZW9tLmNvbG9ycy5wdXNoKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nQ29vcmQucHVzaCh2ZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdWZWNDb2xvci5wdXNoKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9nZW9tLmNlbnRlcigpO1xyXG5cclxuICAgICAgICAgICAgbWF0ID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtzaXplOiAyLCB2ZXJ0ZXhDb2xvcnM6IHRydWV9KTtcclxuICAgICAgICAgICAgbGV0IGNsb3VkID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tLCBtYXQpO1xyXG5cclxuICAgICAgICAgICAgY2xvdWQubmFtZSA9ICdJbWFnZVBhcnRpY2xlJztcclxuICAgICAgICAgICAgY2xvdWQucm90YXRpb24ueSA9IE1hdGguUEkgKiAxLjg7XHJcbiAgICAgICAgICAgIHNjZW5lLmFkZChjbG91ZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnR3ZWVuQW5pbSA9IGZ1bmN0aW9uIHR3ZWVuT2JqKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9tLnZlcnRpY2VzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkdlbnJhdGVHZW9tKGdlb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tLnZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGksIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0d2VlbklucyA9IG5ldyBUV0VFTi5Ud2VlbihlKS50byhcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW1nQ29vcmRbaV0ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGltZ0Nvb3JkW2ldLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1hdGgucmFuZG9tKCkgKiA3NTAgKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KE1hdGgucmFuZG9tKCkgKiAyNTAgKTtcclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbklucy5zdGFydCgpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5BbmltMSA9IGZ1bmN0aW9uIHR3ZWVuT2JqKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGdlb20udmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSwgYXJyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgKiAxMDAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR3ZWVuSW5zID0gbmV3IFRXRUVOLlR3ZWVuKGUpLnRvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbWdDb29yZFtpXS54ICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbWdDb29yZFtpXS55ICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56ICogMiA+IDEwMDAgPyBlLnogKiAyIDogMTAwMS8vZS56XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1hdGgucmFuZG9tKCkgKiA3NTAgKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5Jbk91dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KE1hdGgucmFuZG9tKCkgKiAyNTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuSW5zLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy50d2VlbkFuaW0yID0gZnVuY3Rpb24gdHdlZW5PYmooaW5kZXgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgc2NlbmVJdGVtIG9mIHNjZW5lLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUl0ZW0ubmFtZSA9IFwiSW1hZ2VQYXJ0aWNsZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2NlbmVJdGVtIG9mIHNjZW5lLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NlbmVJdGVtLm1hdGVyaWFsLnNpemUgPSAyLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDE1MDApO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSwgYXJyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHdlZW5JbnMgPSBuZXcgVFdFRU4uVHdlZW4oZSkudG8oXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbWdDb29yZFtpXS54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbWdDb29yZFtpXS55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBpbWdDb29yZFtpXS56Ly9lLnpcclxuICAgICAgICAgICAgICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogNTAwKS5lYXNpbmcoVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5JbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoTWF0aC5yYW5kb20oKSAqIDUwMClcclxuICAgICAgICAgICAgICAgICAgICAub25VcGRhdGUoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc1tpXSA9IGltZ1ZlY0NvbG9yW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHR3ZWVuSW5zLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5BbmltMyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGJmbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IGJXYXZlc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xyXG4gICAgICAgICAgICB3aW5kb3dIYWxmWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcclxuICAgICAgICAgICAgd2luZG93SGFsZlkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG1vdXNlWCA9IGV2ZW50LmNsaWVudFggLSB3aW5kb3dIYWxmWDtcclxuICAgICAgICAgICAgbW91c2VZID0gZXZlbnQuY2xpZW50WSAtIHdpbmRvd0hhbGZZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgbW91c2VYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvd0hhbGZYO1xyXG4gICAgICAgICAgICAgICAgbW91c2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvd0hhbGZZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIG1vdXNlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3dIYWxmWDtcclxuICAgICAgICAgICAgICAgIG1vdXNlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3dIYWxmWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgICAgICBUV0VFTi51cGRhdGUodGltZSk7XHJcbiAgICAgICAgICAgIHJlbmRlcigpO1xyXG4gICAgICAgICAgICBzdGF0cy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAqIDAuMDAwMDU7XHJcblxyXG4gICAgICAgICAgICBpZiAoKChtb3VzZVggLSBjYW1lcmEucG9zaXRpb24ueCkgPiAwICYmIGNhbWVyYS5wb3NpdGlvbi54IDwgIDUwKSB8fFxyXG4gICAgICAgICAgICAgICAgKChtb3VzZVggLSBjYW1lcmEucG9zaXRpb24ueCkgPCAwICYmIGNhbWVyYS5wb3NpdGlvbi54ID4gLTUwKSkge1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKG1vdXNlWCAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoKG1vdXNlWSAtIGNhbWVyYS5wb3NpdGlvbi55KSA+IDAgJiYgY2FtZXJhLnBvc2l0aW9uLnkgPCA1MCkgfHxcclxuICAgICAgICAgICAgICAgICgobW91c2VZIC0gY2FtZXJhLnBvc2l0aW9uLnkpIDwgMCAmJiBjYW1lcmEucG9zaXRpb24ueSA+IC01MCkpIHtcclxuICAgICAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9IChtb3VzZVkgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjAwNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBnZW9tLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb20uY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJlbmRlcl9hcm91bmQodGltZSk7XHJcbiAgICAgICAgICAgIHJlbmRlcl93YXZlKCk7XHJcbiAgICAgICAgICAgIC8vcmVuZGVyX3Ntb2tlKHRpbWUpO1xyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNvbXBvc2VyKTtcclxuICAgICAgICAgICAgY29tcG9zZXIucmVuZGVyKGNsb2NrLmdldERlbHRhKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyX3Ntb2tlKHRpbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBjbG9jay5nZXREZWx0YSgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPTA7aSA8IHNtb2tlX3BhcnRpY2xlcy5sZW5ndGggO2krKyApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgLy8gc21va2VfcGFydGljbGVzW2ldLnJvdGF0aW9uLnggKz0gMC4wMDU7XHJcbiAgICAgICAgICAgICAgIC8vIHNtb2tlX3BhcnRpY2xlc1tpXS5yb3RhdGlvbi55ICs9IDAuMDE7XHJcbiAgICAgICAgICAgICAgICAvL3Ntb2tlX3BhcnRpY2xlc1tpXS5wb3NpdGlvbi5zZXQoTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgLyAxMDgwLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAvIDE4MCwgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgICAgICAgICAgc21va2VfcGFydGljbGVzW2ldLnJvdGF0aW9uLnogKz0gTWF0aC5yYW5kb20oKSAqIGRlbHRhICogMC4xO1xyXG4gICAgICAgICAgICAgICAgLy9zbW9rZV9wYXJ0aWNsZXNbaV0ucG9zaXRpb24ueiA9KE1hdGguc2luKDAuNSkgKiA1MDApO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyX2Fyb3VuZCh0aW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGlfYXJvdW5kID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2VuZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHNjZW5lLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lID09PSAnYXJvdW5kJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRpb24ueSA9IHRpbWUgKiAoaV9hcm91bmQgPCA0ID8gaV9hcm91bmQgKyAxIDogLShpX2Fyb3VuZCArIDEpKSAqIDIuNTtcclxuICAgICAgICAgICAgICAgICAgICBpX2Fyb3VuZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0Lm5hbWUgPT09ICdJbWFnZVBhcnRpY2xlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Qucm90YXRpb24ueSA8IDYuMjgzMTgpIFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJvdGF0aW9uLnkgKz0gTWF0aC5QSSAvIDE4MCAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiZmxhZykgXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhvYmplY3Qucm90YXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi55ID0gNi4yODMxODUzMDcxNzk1ODY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRocmVlSW5zLnR3ZWVuQW5pbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyX3dhdmUoKSB7XHJcbiAgICAgICAgICAgIGxldCBpX3dhdmUgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKChwYXJ0aWNsZXNfd2F2ZS5sZW5ndGggPiBBTU9VTlRYICogQU1PVU5UWSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBiV2F2ZXNpbmcgIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY291bnRfd2F2ZSArPSAwLjE7XHJcbiAgICAgICAgICAgICAgICAvKip3YXZlcyAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IEFNT1VOVFg7IGl4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpeSA9IDA7IGl5IDwgQU1PVU5UWTsgaXkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHggPSBpeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5ID0gaXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZV93YXZlID0gcGFydGljbGVzX3dhdmVbaV93YXZlKytdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5wb3NpdGlvbi55ID0gcGFydGljbGVfd2F2ZS5wb3NpdGlvbi55ICsgTWF0aC5zaW4oKHR4ICsgY291bnRfd2F2ZSkgKiAwLjMpICogMS41ICArIChNYXRoLnNpbigodHkgKyBjb3VudF93YXZlKSAqIDAuNSkpIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZS5zY2FsZS54ID0gcGFydGljbGVfd2F2ZS5zY2FsZS55ID0gKE1hdGguc2luKCh0eCArIGNvdW50X3dhdmUpICogMC4zKSArIDEpICogMi41ICsgKE1hdGguc2luKCh0eSArIGNvdW50X3dhdmUpICogMC41KSArIDEpICogMi41O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIFxyXG4gICAgICAgICAgICB7ICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoIWJpc04pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IEFNT1VOVFg7IGl4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXkgPSAwOyBpeSA8IEFNT1VOVFk7IGl5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGVfd2F2ZSA9IHBhcnRpY2xlc193YXZlW2lfd2F2ZSsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wX3JhZCA9IDAuMDU7Ly9NYXRoLnJhbmRvbSgpICogMC4wNSArIDAuMDEgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueCA9IHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueiAqIE1hdGguc2luKHRlbXBfcmFkKSArIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueCAqIE1hdGguY29zKHRlbXBfcmFkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueiA9IHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueiAqIE1hdGguY29zKHRlbXBfcmFkKSAtIHBhcnRpY2xlX3dhdmUucG9zaXRpb24ueCAqIE1hdGguc2luKHRlbXBfcmFkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdGV4Kz0gMC4xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRocmVlSW5zOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/main.js\n");

/***/ })

/******/ });